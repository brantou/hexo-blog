#+TITLE: Leetcode编程练习
#+DATE: <2017-03-21 Tue>
#+LAYOUT: post
#+TAGS: leetcode
#+CATEGORIES: 技术积累
#+STARTUP: content

* maxCount
#+NAME: max-count
#+BEGIN_SRC go
  func maxCount(m int, n int, ops [][]int) int {
    M := make([]([]int), 0,m)
    for i := 0; i < m; i+=1 {
      r := make([]int,n)
      M = append(M, r)
    }
    var max int
    var max_count int
    for index, _ := range ops {
      a, b := ops[index][0],ops[index][1]
      fmt.Println(a,b)
      rs := M[0:a]
      for index, _ := range rs {
        ris := rs[index]
        for index, _ := range ris {
          ri := ris[index]
          if index == b {
            break
          }
          ri +=1
          ris[index]=ri
          if ri > max {
            max = ri
            max_count = 0
          }
          if ri == max {
            max_count +=1
          }
        }
        rs[index] = ris
      }
    }
    return max_count
  }
#+END_SRC

#+NAME: max-count-smp
#+BEGIN_SRC go
  func maxCount(m int, n int, ops [][]int) int {
    m_r, m_c := m, n
    for _, op := range ops {
      op_r := op[0]
      op_c := op[1]
      if op_r < m_r {
        m_r = op_r
      }
      if op_c < m_c {
        m_c = op_c
      }
    }
    return m_r * m_c
  }
#+END_SRC

#+BEGIN_SRC go :imports '("fmt") :noweb strip-export
  <<max-count-smp>>
  func main() {
      fmt.Println(maxCount(3,3, [][]int{[]int{2,2},[]int{3,3}}))
  }
#+END_SRC

#+RESULTS:
: 4

* twoSum
#+BEGIN_SRC go
func twoSum(nums []int, target int) []int {
    indices := make([]int, 0)
    for i := 0; i < len(nums); i += 1 {
        fir := nums[i]
        for j := i+1; j < len(nums); j +=1 {
            secd := nums[j]
            if fir + secd == target {
                indices = append(indices, i)
                indices = append(indices, j)
                break
            }
        }
    }
    return indices
}
#+END_SRC

#+NAME: add-two-number
#+BEGIN_SRC go
  /**
   ,* Definition for singly-linked list.
   ,* type ListNode struct {
   ,*     Val int
   ,*     Next *ListNode
   ,* }
   ,*/
  func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    var carry int
    var sum_head, sum_curr *ListNode
    for {
      if l1 == nil && l2 == nil {
        if carry > 0 {
          sum_node := &ListNode{
            Val:  carry,
            Next: nil,
          }
          if sum_head != nil {
            sum_curr.Next = sum_node
            sum_curr = sum_node
          } else {
            sum_head = sum_node
            sum_curr = sum_node
          }
        }
        break
      }

      var sum int
      if l1 != nil && l2 != nil {
        sum = l1.Val + l2.Val + carry
        l1, l2 = l1.Next, l2.Next
      } else if l2 == nil {
        sum = l1.Val + carry
        l1 = l1.Next
      } else if l1 == nil {
        sum = l2.Val + carry
        l2 = l2.Next
      }

      if sum > 9 {
        carry = 1
        sum -= 10
      } else {
        carry = 0
      }

      sum_node := &ListNode{
        Val:  sum,
        Next: nil,
      }
      if sum_head != nil {
        sum_curr.Next = sum_node
        sum_curr = sum_node
      } else {
        sum_head = sum_node
        sum_curr = sum_node
      }
    }
    return sum_head
  }
#+END_SRC

#+BEGIN_SRC go :imports '("fmt" "strings") :noweb strip-export
  type ListNode struct {
    Val int
    Next *ListNode
  }

  <<add-two-number>>

  func make_list(vals []int) *ListNode{
    var lst, lst_c *ListNode
    for _, val := range vals {
      node := &ListNode{
        Val: val,
        Next: nil,
      }
      if lst != nil {
        lst_c.Next = node
        lst_c = node
      } else {
        lst = node
        lst_c = node
      }
    }
    return lst
  }

  func print_list(lst *ListNode) {
    var str string
    for {
      if lst == nil {
        break
      }
      str += fmt.Sprintf("%d,", lst.Val)
      lst = lst.Next
    }
    str = strings.Trim(str, ",")
    fmt.Printf("[%s]", str)
  }

  func main() {
    l1 := make_list([]int{2,4,3})
    l2 := make_list([]int{5,6,4})
    sum_lst := addTwoNumbers(l1,l2)
    print_list(sum_lst)
  }

#+END_SRC

* lengthOfLongestSubstring
#+NAME: longest-sub-str
#+BEGIN_SRC go
  func lengthOfLongestSubstring(s string) int {
    byte_arr := []byte(s)
    max_sub_arr := make([]byte, 0)
    byte_sub_arr := make([]byte, 0)
    byte_m := make(map[byte]int)
    var start_index int
    for index, byte_i := range byte_arr {
      if ori_index, ok := byte_m[byte_i]; !ok {
        byte_m[byte_i] = index
        byte_sub_arr = append(byte_sub_arr, byte_i)
      } else {
        if len(max_sub_arr) < len(byte_sub_arr) {
          max_sub_arr = byte_sub_arr
        }
        byte_sub_arr = byte_arr[ori_index+1 : index+1]
        for ; start_index <= ori_index; start_index += 1 {
          delete(byte_m, byte_arr[start_index])
        }
        byte_m[byte_i] = index
      }
    }
    if len(max_sub_arr) < len(byte_sub_arr) {
      max_sub_arr = byte_sub_arr
    }
    return len(max_sub_arr)
  }
#+END_SRC

#+BEGIN_SRC go :imports "fmt" :noweb strip-export
  <<longest-sub-str>>
  func main() {
    fmt.Println(lengthOfLongestSubstring("abcabcbb"))
  }
#+END_SRC

#+RESULTS:
: 3

* findMedianSortedArrays
#+NAME: find-median-sorted-arr
#+BEGIN_SRC go
  func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
    total := len(nums1) + len(nums2)
    if total%2 > 0 {
      return findKth(nums1, nums2, total/2+1)
    } else {
      return (findKth(nums1, nums2, total/2) + findKth(nums1, nums2, total/2+1)) / float64(2)
    }
  }

  func min(a, b int) int {
    if a > b {
      return b
    } else {
      return a
    }
  }

  func findKth(a []int, b []int, k int ) float64 {
    m, n := len(a), len(b)

    //always assume that m is equal or smaller than n
    if m > n {
      return findKth(b, a, k)
    }
    if m == 0 {
      return float64(b[k-1])
    }

    if k == 1 {
      return float64(min(a[0], b[0]))
    }

    //divide k into two parts
    pa := min(k/2, m)
    pb := k - pa
    if a[pa-1] < b[pb-1] {
      return findKth(a[pa:], b, k-pa)
    } else if a[pa-1] > b[pb-1] {
      return findKth(a, b[pb:], k-pb)
    } else {
      return float64(a[pa-1])
    }
  }
#+END_SRC

#+BEGIN_SRC go :imports "fmt" :noweb strip-export :tangle ../src/leetcode/find_median_sorted.go :mkdirp yes
  <<find-median-sorted-arr>>
  func main() {
    fmt.Println(findMedianSortedArrays([]int{1,3}, []int{2}))
    fmt.Println(findMedianSortedArrays([]int{1,2}, []int{3, 4}))
    fmt.Println(findMedianSortedArrays([]int{2,4,8}, []int{3,6,9}))
    fmt.Println(findMedianSortedArrays([]int{2,4,7,8}, []int{3,5,6,9}))
  }
#+END_SRC

#+RESULTS:
: 2
: 2.5
: 5

* findMin
#+BEGIN_SRC go
  func findMin(nums []int) int {
    if len(nums) < 1 {
      return 0
    }

    if len(nums) == 1 {
      return nums[0]
    }

    if len(nums) == 2 {
      return min(nums[0], nums[1])
    }

    size := len(nums)
    max_min_num := nums[0]
    mid_num := nums[size/2]
    if mid_num > max_min_num {
      return findMin(nums[size/2+1:])
    } else {
      if nums[size/2-1] > nums[size/2] {
        return nums[size/2]
      } else {
        return findMin(nums[:size/2])
      }
    }
  }

  func min(a, b int) int{
    if a > b{
      return b
    } else {
      return a
    }
  }
#+END_SRC

* findDiagonalOrder
#+BEGIN_SRC go
  func findDiagonalOrder(matrix [][]int) []int {
    rst_arr := make([]int, 0)
    if len(martix) < 1 || len(matrix[0]) < 1 {
      return rst_arr
    }
    r_n := len(matrix)
    c_n := len(matrix[0])
    max_n := max(r_n, c_n)
    order := "asc" // desc
    var r_index, c_index int
    for {
      if r_index == r_n-1 && c_index == c_n-1 {
        rst_arr = append(rst_arr, matrix[r_index][c_index])
        break
      }

      switch order {
      case "asc":
        order = "desc"
        for {
          rst_arr = append(rst_arr, matrix[r_index][c_index])
          if c_index == c_n-1 || r_index == 0 {
            break
          }
          c_index += 1
          r_index -= 1
        }

        if r_index == 0 {
          if c_index == c_n-1 {
            r_index += 1
          } else {
            c_index += 1
          }
        } else if c_index == c_n-1 {
          r_index += 1
        }
      case "desc":
        order = "asc"
        for {
          rst_arr = append(rst_arr, matrix[r_index][c_index])
          if c_index == 0 || r_index == r_n-1 {
            break
          }
          c_index -= 1
          r_index += 1
        }

        if c_index == 0 {
          if r_index == r_n-1 {
            c_index += 1
          } else {
            r_index += 1
          }
        } else if r_index == r_n-1 {
          c_index += 1
        }
      }
    }
    return rst_arr
  }
#+END_SRC

* thirdMax
#+NAME: third-max
#+BEGIN_SRC go
  func parent(i int) int {
    return i / 2
  }

  func left(i int) int {
    return 2*i + 1
  }

  func right(i int) int {
    return 2 * (i + 1)
  }

  func min_heapify(A []int, i int) {
    l := left(i)
    r := right(i)
    var least int
    if l < len(A) && A[l] < A[i] {
      least = l
    } else {
      least = i
    }
    if r < len(A) && A[r] < A[least] {
      least = r
    }

    if least != i {
      A[i], A[least] = A[least], A[i]
      min_heapify(A, least)
    }
  }

  func thirdMax(nums []int) int {
    var size int = 3
    min_heap := make([]int, 0)
    heap_M := make(map[int]bool)
    var index int
    for {
      if !heap_M[nums[index]] {
        heap_M[nums[index]] = true
        min_heap = append(min_heap, nums[index])
      }
      index += 1
      if len(min_heap) == size {
        break
      }
      if index == len(nums) {
        break
      }
    }

    for i := len(min_heap) / 2; i >= 0; i -= 1 {
      min_heapify(min_heap, i)
    }

    if index == len(nums) {
      if len(min_heap) == size {
        return min_heap[0]
      } else {
        var max int
        for _, num := range min_heap {
          if num > max {
            max = num
          }
        }
        return max
      }
    }

    for i := index; i < len(nums); i += 1 {
      num := nums[i]
      if num > min_heap[0] && !heap_M[num] {
        delete(heap_M, min_heap[0])
        heap_M[num] = true
        min_heap[0] = num
        min_heapify(min_heap, 0)
      }
    }

    return min_heap[0]
  }
#+END_SRC

#+BEGIN_SRC go :imports "fmt" :noweb strip-export
  <<third-max>>
  func main() {
    fmt.Println(thirdMax([]int{3, 2, 1}))
    fmt.Println(thirdMax([]int{1, 2}))
    fmt.Println(thirdMax([]int{2, 2, 3, 1}))
    fmt.Println(thirdMax([]int{5,2,4,1,3,6,0}))
  }
#+END_SRC

#+RESULTS:
: 1
: 2
: 1
: [3 5 4]
: [4 5 6]
: 4

* combinationSum
** combinationSum
#+NAME: combin-sum
#+BEGIN_SRC go
  type PreCombin struct {
    Sum int
    Arr []int
  }

  func IsEqualCombin(lc, rc *PreCombin) bool {
    if lc.Sum != rc.Sum {
      return false
    }

    if len(lc.Arr) != len(rc.Arr) {
      return false
    }

    for i := 0; i < len(lc.Arr); i += 1 {
      l_num := lc.Arr[i]
      r_num := rc.Arr[i]
      if l_num != r_num {
        return false
      }
    }
    return true
  }

  func sortInsert(nums []int, num int) []int {
    if len(nums) < 1 {
      return []int{num}
    }
    new_nums := make([]int, len(nums)+1)
    copy(new_nums, nums)
    new_nums[len(nums)] = num

    num_index := len(new_nums) - 1
    for i := len(new_nums) - 2; i >= 0; i -= 1 {
      if new_nums[i] <= new_nums[num_index] {
        break
      }
      new_nums[i], new_nums[num_index] = new_nums[num_index], new_nums[i]
      num_index = i
    }
    return new_nums
  }

  func combinationSum(candidates []int, target int) [][]int {
    combin_arr := make([]([]int), 0)
    pre_combin_arr := make([]*PreCombin, 0)
    for index, _ := range candidates {
      num := candidates[index]
      if num > target {
        continue
      }

      sub_pre_combin_arr := make([]*PreCombin, 0)
      for index, _ := range pre_combin_arr {
        pre_combin := pre_combin_arr[index]
        if pre_combin.Sum == target {
          continue
        }

        for {
          if pre_combin.Sum+num <= target {
            _pre_combin := &PreCombin{
              Sum: pre_combin.Sum + num,
              Arr: sortInsert(pre_combin.Arr, num),
            }
            sub_pre_combin_arr = append(sub_pre_combin_arr, _pre_combin)
            pre_combin = _pre_combin
          } else {
            break
          }
        }
      }

      pre_combin := &PreCombin{
        Sum: num,
        Arr: []int{num},
      }
      sub_pre_combin_arr = append(sub_pre_combin_arr, pre_combin)
      for {
        if pre_combin.Sum+num <= target {
          _pre_combin := &PreCombin{
            Sum: pre_combin.Sum + num,
            Arr: sortInsert(pre_combin.Arr, num),
          }
          sub_pre_combin_arr = append(sub_pre_combin_arr, _pre_combin)
          pre_combin = _pre_combin
        } else {
          break
        }
      }

      for index, _ := range sub_pre_combin_arr {
        sub_pre_combin := sub_pre_combin_arr[index]
        var hasEqual bool
        for index, _ := range pre_combin_arr {
          pre_combin := pre_combin_arr[index]
          if IsEqualCombin(sub_pre_combin, pre_combin) {
            hasEqual = true
            break
          }
        }
        if !hasEqual {
          pre_combin_arr = append(pre_combin_arr, sub_pre_combin)
        }
      }
    }

    for index, _ := range pre_combin_arr {
      pre_combin := pre_combin_arr[index]
      if pre_combin.Sum == target {
        combin_arr = append(combin_arr, pre_combin.Arr)
      }
    }

    return combin_arr
  }
#+END_SRC

#+BEGIN_SRC go :imports "fmt" :noweb strip-export
  <<combin-sum>>
  func main() {
    fmt.Println(combinationSum([]int{2, 3, 6, 7}, 7))
  }
#+END_SRC

#+RESULTS:
: [[2 2 3] [7]]

** combinationSum2
#+NAME: combin-sum-2
#+BEGIN_SRC go
  type PreCombin struct {
    Sum int
    Arr []int
  }

  func IsEqualCombin(lc, rc *PreCombin) bool {
    if lc.Sum != rc.Sum {
      return false
    }

    if len(lc.Arr) != len(rc.Arr) {
      return false
    }

    for i := 0; i < len(lc.Arr); i += 1 {
      l_num := lc.Arr[i]
      r_num := rc.Arr[i]
      if l_num != r_num {
        return false
      }
    }
    return true
  }

  func sortInsert(nums []int, num int) []int {
    if len(nums) < 1 {
      return []int{num}
    }
    new_nums := make([]int, len(nums)+1)
    copy(new_nums, nums)
    new_nums[len(nums)] = num

    num_index := len(new_nums) - 1
    for i := len(new_nums) - 2; i >= 0; i -= 1 {
      if new_nums[i] <= new_nums[num_index] {
        break
      }
      new_nums[i], new_nums[num_index] = new_nums[num_index], new_nums[i]
      num_index = i
    }
    return new_nums
  }

  func combinationSum2(candidates []int, target int) [][]int {
    combin_arr := make([]([]int), 0)
    pre_combin_arr := make([]*PreCombin, 0)
    for index, _ := range candidates {
      num := candidates[index]
      if num > target {
        continue
      }

      sub_pre_combin_arr := make([]*PreCombin, 0)
      for index, _ := range pre_combin_arr {
        pre_combin := pre_combin_arr[index]
        if pre_combin.Sum == target {
          continue
        }
        if pre_combin.Sum+num <= target {
          _pre_combin := &PreCombin{
            Sum: pre_combin.Sum + num,
            Arr: sortInsert(pre_combin.Arr, num),
          }
          sub_pre_combin_arr = append(sub_pre_combin_arr, _pre_combin)
        }
      }

      pre_combin := &PreCombin{
        Sum: num,
        Arr: []int{num},
      }
      sub_pre_combin_arr = append(sub_pre_combin_arr, pre_combin)

      for index, _ := range sub_pre_combin_arr {
        sub_pre_combin := sub_pre_combin_arr[index]
        var hasEqual bool
        for index, _ := range pre_combin_arr {
          pre_combin := pre_combin_arr[index]
          if IsEqualCombin(sub_pre_combin, pre_combin) {
            hasEqual = true
            break
          }
        }
        if !hasEqual {
          pre_combin_arr = append(pre_combin_arr, sub_pre_combin)
        }
      }
    }

    for index, _ := range pre_combin_arr {
      pre_combin := pre_combin_arr[index]
      if pre_combin.Sum == target {
        combin_arr = append(combin_arr, pre_combin.Arr)
      }
    }

    return combin_arr
  }
#+END_SRC

#+BEGIN_SRC go :imports "fmt" :noweb strip-export
  <<combin-sum-2>>
  func main() {
    fmt.Println(combinationSum2([]int{10, 1, 2, 7, 6, 1, 5}, 8))
    fmt.Println(combinationSum2([]int{4,4,2,1,4,2,2,1,3}, 6))
    fmt.Println(combinationSum2([]int{3,1,3,5,1,1}, 8))
  }
#+END_SRC

#+RESULTS:
: [[3 5] [1 1 3 3] [1 1 1 5]]

** combinationSum3
   #+NAME: combin-sum-3
   #+BEGIN_SRC go
     type PreCombin struct {
       Sum int
       Arr []int
     }

     func IsEqualCombin(lc, rc *PreCombin) bool {
       if lc.Sum != rc.Sum {
         return false
       }

       if len(lc.Arr) != len(rc.Arr) {
         return false
       }

       for i := 0; i < len(lc.Arr); i += 1 {
         l_num := lc.Arr[i]
         r_num := rc.Arr[i]
         if l_num != r_num {
           return false
         }
       }
       return true
     }

     func sortInsert(nums []int, num int) []int {
       if len(nums) < 1 {
         return []int{num}
       }
       new_nums := make([]int, len(nums)+1)
       copy(new_nums, nums)
       new_nums[len(nums)] = num

       num_index := len(new_nums) - 1
       for i := len(new_nums) - 2; i >= 0; i -= 1 {
         if new_nums[i] <= new_nums[num_index] {
           break
         }
         new_nums[i], new_nums[num_index] = new_nums[num_index], new_nums[i]
         num_index = i
       }
       return new_nums
     }

     func combinationSum3(k int, n int) [][]int {
       candidates := make([]int, 9)
       for index, _ := range candidates {
         candidates[index] = index + 1
       }
       target := n

       combin_arr := make([]([]int), 0)
       pre_combin_arr := make([]*PreCombin, 0)
       for index, _ := range candidates {
         num := candidates[index]
         if num > target {
           continue
         }

         sub_pre_combin_arr := make([]*PreCombin, 0)
         for index, _ := range pre_combin_arr {
           pre_combin := pre_combin_arr[index]
           if pre_combin.Sum == target {
             continue
           }
           if pre_combin.Sum+num <= target {
             _pre_combin := &PreCombin{
               Sum: pre_combin.Sum + num,
               Arr: sortInsert(pre_combin.Arr, num),
             }
             sub_pre_combin_arr = append(sub_pre_combin_arr, _pre_combin)
           }
         }

         pre_combin := &PreCombin{
           Sum: num,
           Arr: []int{num},
         }
         sub_pre_combin_arr = append(sub_pre_combin_arr, pre_combin)

         for index, _ := range sub_pre_combin_arr {
           sub_pre_combin := sub_pre_combin_arr[index]
           var hasEqual bool
           for index, _ := range pre_combin_arr {
             pre_combin := pre_combin_arr[index]
             if IsEqualCombin(sub_pre_combin, pre_combin) {
               hasEqual = true
               break
             }
           }
           if !hasEqual {
             pre_combin_arr = append(pre_combin_arr, sub_pre_combin)
           }
         }
       }


       for index, _ := range pre_combin_arr {
         pre_combin := pre_combin_arr[index]
         if pre_combin.Sum == target && len(pre_combin.Arr) == k {
           combin_arr = append(combin_arr, pre_combin.Arr)
         }
       }

       return combin_arr
     }
   #+END_SRC

   #+BEGIN_SRC go :imports "fmt" :noweb strip-export
        <<combin-sum-3>>
        func main() {
          fmt.Println(combinationSum3(3, 7))
          fmt.Println(combinationSum3(3, 9))
        }
    #+END_SRC

** combinationSum4
*** V1
#+NAME: combin-sum-4v1
#+BEGIN_SRC go
  type PreCombin struct {
    Sum int
    Arr []int
  }

  func IsEqualCombin(lc, rc *PreCombin) bool {
    if lc.Sum != rc.Sum {
      return false
    }

    if len(lc.Arr) != len(rc.Arr) {
      return false
    }

    for i := 0; i < len(lc.Arr); i += 1 {
      l_num := lc.Arr[i]
      r_num := rc.Arr[i]
      if l_num != r_num {
        return false
      }
    }
    return true
  }

  func sortInsert(nums []int, num int) []int {
    if len(nums) < 1 {
      return []int{num}
    }
    new_nums := make([]int, len(nums)+1)
    copy(new_nums, nums)
    new_nums[len(nums)] = num

    num_index := len(new_nums) - 1
    for i := len(new_nums) - 2; i >= 0; i -= 1 {
      if new_nums[i] <= new_nums[num_index] {
        break
      }
      new_nums[i], new_nums[num_index] = new_nums[num_index], new_nums[i]
      num_index = i
    }
    return new_nums
  }

  func permut_num(nums []int) int {
    size := len(nums)
    num_M := make(map[int]int)
    for _, num := range nums {
      num_M[num] += 1
    }

    if len(num_M) == 1 {
      return 1
    }

    var max_count int
    var max_count_num int
    for num, count := range num_M {
      if count > max_count {
        max_count = count
        max_count_num = num
      }
    }
    delete(num_M, max_count_num)

    var factor int = 1
    for i := size; i > max_count; i -= 1 {
      factor *= i
    }

    var un_factor int = 1
    for _, count := range num_M {
      for i := count; i > 0; i -= 1 {
        un_factor *= i
      }
    }

    return factor / un_factor
  }

  func combinationSum4(nums []int, target int) int {
    pre_combin_arr := make([]*PreCombin, 0)
    for index, _ := range nums {
      num := nums[index]
      if num > target {
        continue
      }

      sub_pre_combin_arr := make([]*PreCombin, 0)
      for index, _ := range pre_combin_arr {
        pre_combin := pre_combin_arr[index]
        if pre_combin.Sum == target {
          continue
        }

        for {
          if pre_combin.Sum+num <= target {
            _pre_combin := &PreCombin{
              Sum: pre_combin.Sum + num,
              Arr: sortInsert(pre_combin.Arr, num),
            }
            sub_pre_combin_arr = append(sub_pre_combin_arr, _pre_combin)
            pre_combin = _pre_combin
          } else {
            break
          }
        }
      }

      pre_combin := &PreCombin{
        Sum: num,
        Arr: []int{num},
      }
      sub_pre_combin_arr = append(sub_pre_combin_arr, pre_combin)
      for {
        if pre_combin.Sum+num <= target {
          _pre_combin := &PreCombin{
            Sum: pre_combin.Sum + num,
            Arr: sortInsert(pre_combin.Arr, num),
          }
          sub_pre_combin_arr = append(sub_pre_combin_arr, _pre_combin)
          pre_combin = _pre_combin
        } else {
          break
        }
      }

      for index, _ := range sub_pre_combin_arr {
        sub_pre_combin := sub_pre_combin_arr[index]
        var hasEqual bool
        for index, _ := range pre_combin_arr {
          pre_combin := pre_combin_arr[index]
          if IsEqualCombin(sub_pre_combin, pre_combin) {
            hasEqual = true
            break
          }
        }
        if !hasEqual {
          pre_combin_arr = append(pre_combin_arr, sub_pre_combin)
        }
      }
    }

    var permuts int
    for index, _ := range pre_combin_arr {
      pre_combin := pre_combin_arr[index]
      if pre_combin.Sum == target {
        permuts += permut_num(pre_combin.Arr)
      }
    }

    return permuts
  }
#+END_SRC
*** V2
#+NAME: combin-sum-4v2
#+BEGIN_SRC go
  func permut_num(num_M map[int]int) int {
    if len(num_M) == 1 {
      return 1
    }

    var sum_count int
    var max_count int
    var max_count_num int
    for num, count := range num_M {
      sum_count += count
      if count > max_count {
        max_count = count
        max_count_num = num
      }
    }
    delete(num_M, max_count_num)

    var factor int = 1
    for i := sum_count; i > max_count; i -= 1 {
      factor *= i
    }

    var un_factor int = 1
    for _, count := range num_M {
      for i := count; i > 0; i -= 1 {
        un_factor *= i
      }
    }

    return factor / un_factor
  }

  func combinationSum4(nums []int, target int) int {
    var result_num int
    if len(nums) == 0 {
      return 0
    }

    if len(nums) == 1 {
      if target%nums[0] == 0 {
        return 1
      } else {
        return 0
      }
    }

    fir_num := nums[0]
    var factor int = 0
    for sub_sum := 0; sub_sum <= target; sub_sum += fir_num {
      combin_M_arr := sub_combin(nums[1:], target-fir_num*factor)
      if len(combin_M_arr) > 0 {
        for index, _ := range combin_M_arr {
          combin_M := combin_M_arr[index]
          combin_M[fir_num] = factor
          result_num += permut_num(combin_M)
        }
      }
      if fir_num*factor == target {
        result_num += 1
      }
      factor += 1
    }

    return result_num
  }

  func sub_combin(nums []int, target int) [](map[int]int) {
    if target < 1 {
      return []map[int]int{}
    }

    if len(nums) == 1 {
      if target%nums[0] == 0 {
        return []map[int]int{
          map[int]int{
            nums[0]: target / nums[0],
          },
        }
      } else {
        return []map[int]int{}
      }
    }

    fir_num := nums[0]
    var factor int = 0
    combin_M_arr := make([]map[int]int, 0)
    for sub_sum := 0; sub_sum <= target; sub_sum += fir_num {
      sub_combin_M_arr := sub_combin(nums[1:], target-fir_num*factor)
      if len(sub_combin_M_arr) > 0 {
        for index, _ := range sub_combin_M_arr {
          combin_M := sub_combin_M_arr[index]
          combin_M[fir_num] = factor
          combin_M_arr = append(combin_M_arr, combin_M)
        }
      }

      if fir_num*factor == target {
        combin_M := map[int]int{
          fir_num: factor,
        }
        combin_M_arr = append(combin_M_arr, combin_M)
      }

      factor += 1
    }

    return combin_M_arr
  }
#+END_SRC

#+BEGIN_SRC go :imports "fmt" :noweb strip-export
  <<combin-sum-4v2>>
  func main() {
    fmt.Println(combinationSum4([]int{1,2,3}, 4))
    fmt.Println(combinationSum4([]int{1,50}, 200))
    fmt.Println(combinationSum4([]int{3,33,333}, 10000))
  }
#+END_SRC

*** V3
    动态规划解法
    #+BEGIN_QUOTE
    - dp[i] += dp[i-num]
    - dp[i+num] += dp[i]
    #+END_QUOTE

    #+NAME: combin-sum-4v3
    #+BEGIN_SRC go
      func combinationSum4(nums []int, target int) int {
        dp := make([]int, target+1)
        dp[0] = 1
        for i := 1; i <= target; i += 1 {
          for _, num := range nums {
            if i >= num {
              dp[i] += dp[i-num]
            }
          }
        }
        return dp[target]
      }
    #+END_SRC

    #+BEGIN_SRC go :imports "fmt" :noweb strip-export
        <<combin-sum-4v3>>
        func main() {
          fmt.Println(combinationSum4([]int{1,2,3}, 4))
          fmt.Println(combinationSum4([]int{1,50}, 200))
          fmt.Println(combinationSum4([]int{3,33,333}, 10000))
        }
    #+END_SRC

* combine
#+NAME: combine
#+BEGIN_SRC go
  func combine(n int, k int) [][]int {
    return subCombine(1, n, k)
  }

  func subCombine(start, end, k int) [][]int {
    if k < 1 || end-start+1 < k {
      return [][]int{}
    }

    combine_arr := make([][]int, 0)
    if k == 1 {
      for i := start; i <= end; i += 1 {
        combine_arr = append(combine_arr, []int{i})
      }
    }

    for i := start; i <= end-(k-1); i += 1 {
      sub_combine_arr := subCombine(i+1, end, k-1)
      if len(sub_combine_arr) > 0 {
        for index, _ := range sub_combine_arr {
          combines := append([]int{i}, sub_combine_arr[index]...)
          combine_arr = append(combine_arr, combines)
        }
      }
    }

    return combine_arr
  }
#+END_SRC

#+BEGIN_SRC go :imports "fmt" :noweb strip-export
  <<combine>>
  func main() {
    fmt.Println(combine(4,2))
  }
#+END_SRC

#+RESULTS:
: [[1 2] [1 3] [1 4] [2 3] [2 4] [3 4]]

* pathSum
** hasPathSum
   #+NAME: has-path-sum
   #+BEGIN_SRC go
     type TreeNode struct {
       Val   int
       Left  *TreeNode
       Right *TreeNode
     }

     func hasPathSum(root *TreeNode, sum int) bool {
       if root == nil {
         return false
       }

       if root.Left == nil && root.Right == nil {
         if root.Val == sum {
           return true
         } else {
           return false
         }
       }

       return hasPathSum(root.Left, sum-root.Val) || hasPathSum(root.Right, sum-root.Val)
     }
   #+END_SRC

   #+BEGIN_SRC go :imports "fmt" :noweb strip-export
    <<has-path-sum>>
    func main() {
      lc := &TreeNode{
        Val: 4,
        Left: &TreeNode{
          Val: 11,
          Left: &TreeNode{
            Val: 7,
          },
          Right: &TreeNode{
            Val: 2,
          },
        },
      }
      rc := &TreeNode{
        Val: 8,
        Left: &TreeNode{
          Val: 13,
        },
        Right: &TreeNode{
          Val: 4,
          Left: &TreeNode{
            Val: 5,
          },
          Right: &TreeNode{
            Val: 1,
          },
        },
      }
      root := &TreeNode{
        Val:   5,
        Left:  lc,
        Right: rc,
      }

      fmt.Println(hasPathSum(root, 22))
    }
   #+END_SRC

   #+RESULTS:
   : true

** pathSum
  #+NAME: path-sum
  #+BEGIN_SRC go
    type TreeNode struct {
      Val   int
      Left  *TreeNode
      Right *TreeNode
    }

    func pathSum(root *TreeNode, sum int) [][]int {
      if root == nil {
        return [][]int{}
      }

      if root.Left == nil && root.Right == nil {
        if root.Val == sum {
          return [][]int{[]int{root.Val}}
        } else {
          return [][]int{}
        }
      }

      var lc_path_arr, rc_path_arr [][]int
      if root.Left != nil {
        lc_path_arr = pathSum(root.Left, sum-root.Val)
      }

      if root.Right != nil {
        rc_path_arr = pathSum(root.Right, sum-root.Val)
      }

      path_arr := make([][]int, 0)
      if len(lc_path_arr) > 0 {
        for index, _ := range lc_path_arr {
          path := lc_path_arr[index]
          path = append([]int{root.Val}, path...)
          path_arr = append(path_arr, path)
        }
      }

      if len(rc_path_arr) > 0 {
        for index, _ := range rc_path_arr {
          path := rc_path_arr[index]
          path = append([]int{root.Val}, path...)
          path_arr = append(path_arr, path)
        }
      }

      return path_arr
    }
  #+END_SRC

  #+BEGIN_SRC go :imports "fmt" :noweb strip-export
    <<path-sum>>
    func main() {
      lc := &TreeNode{
        Val: 4,
        Left: &TreeNode{
          Val: 11,
          Left: &TreeNode{
            Val: 7,
          },
          Right: &TreeNode{
            Val: 2,
          },
        },
      }
      rc := &TreeNode{
        Val: 8,
        Left: &TreeNode{
          Val: 13,
        },
        Right: &TreeNode{
          Val: 4,
          Left: &TreeNode{
            Val: 5,
          },
          Right: &TreeNode{
            Val: 1,
          },
        },
      }
      root := &TreeNode{
        Val:   5,
        Left:  lc,
        Right: rc,
      }

      fmt.Println(pathSum(root, 22))
    }
  #+END_SRC

** number of path
   #+NAME: path-sum-number
   #+BEGIN_SRC go
     type TreeNode struct {
       Val   int
       Left  *TreeNode
       Right *TreeNode
     }

     func pathSum(root *TreeNode, sum int) int {
       if root == nil {
         return 0
       }

       return sumUp(root, 0, sum) + pathSum(root.Left, sum) + pathSum(root.Right, sum)
     }

     func sumUp(node *TreeNode, pre, sum int) int {
       if node == nil {
         return 0
       }

       var cur int = pre + node.Val
       var res_num int
       if cur == sum {
         res_num += 1
       }
       return res_num + sumUp(node.Left, cur, sum) + sumUp(node.Right, cur, sum)
     }
   #+END_SRC

   #+BEGIN_SRC go :imports "fmt" :noweb strip-export
     <<path-sum-number>>
     func main() {
       lc := &TreeNode{
         Val: 5,
         Left: &TreeNode{
           Val: 3,
           Left: &TreeNode{
             Val: 3,
           },
           Right: &TreeNode{
             Val: -2,
           },
         },
         Right: &TreeNode{
           Val: 2,
           Right: &TreeNode{
             Val: 1,
           },
         },
       }
       rc := &TreeNode{
         Val: -3,
         Right: &TreeNode{
           Val: 11,
         },
       }
       root := &TreeNode{
         Val:   10,
         Left:  lc,
         Right: rc,
       }

       fmt.Println(pathSum(root, 8))
     }
   #+END_SRC

   #+RESULTS:
   : 3
** min path sum
   #+NAME: min-path-sum
   #+BEGIN_SRC  go
     func minPathSum(grid [][]int) int {
       dp := make([][]int, len(grid))
       for index, _ := range dp {
         dp[index] = make([]int, len(grid[0]))
       }

       for r_i, _ := range grid {
         for c_i, _ := range grid[r_i] {
           if r_i == 0 {
             if c_i > 0 {
               dp[r_i][c_i] = grid[r_i][c_i] + dp[r_i][c_i-1]
             } else {
               dp[r_i][c_i] = grid[r_i][c_i]
             }
             continue
           }
           if c_i == 0 {
             dp[r_i][0] = grid[r_i][0] + dp[r_i-1][0]
             continue
           }

           dp[r_i][c_i] = grid[r_i][c_i] + min(dp[r_i-1][c_i], dp[r_i][c_i-1])
         }
       }

       return dp[len(dp)-1][len(dp[0])-1]
     }

     func min(a, b int) int {
       if a > b {
         return b
       } else {
         return a
       }
     }
   #+END_SRC

   #+BEGIN_SRC go :imports "fmt" :noweb strip-export
     <<min-path-sum>>
     func main() {
       fmt.Println(minPathSum([][]int{
         []int{1, 3, 1},
         []int{1, 5, 1},
         []int{4, 2, 1},
       }))
     }
   #+END_SRC

   #+RESULTS:
   : 7
** binary-tree maximum path sum
   #+NAME: max-path-sum
   #+BEGIN_SRC go
     type TreeNode struct {
       Val   int
       Left  *TreeNode
       Right *TreeNode
     }

     type BpNode struct {
       MaxSum_c int
       MaxSum_b int
       Val      int
       Left     *BpNode
       Right    *BpNode
     }

     func copyTree2Bp(root *TreeNode) *BpNode {
       if root == nil {
         return nil
       }

       return &BpNode{
         Val:   root.Val,
         Left:  copyTree2Bp(root.Left),
         Right: copyTree2Bp(root.Right),
       }
     }

     func max(a, b int) int {
       if a < b {
         return b
       } else {
         return a
       }
     }

     func bpMaxSum(bpr *BpNode) int {
       if bpr == nil {
         return 0
       }

       max_n := max(bpr.MaxSum_c, bpr.MaxSum_b)
       if bpr.Left != nil {
         max_n = max(max_n, bpMaxSum(bpr.Left))
       }
       if bpr.Right != nil {
         max_n = max(max_n, bpMaxSum(bpr.Right))
       }

       return max_n
     }

     func maxPathSum(root *TreeNode) int {
       bpr := copyTree2Bp(root)
       maxPathSumHelper(bpr)
       return bpMaxSum(bpr)
     }

     func maxPathSumHelper(bpr *BpNode) (
       max_sum_b int,
     ) {
       if bpr == nil {
         return 0
       }

       lmax_sum_b := maxPathSumHelper(bpr.Left)
       rmax_sum_b := maxPathSumHelper(bpr.Right)

       bpr.MaxSum_c = bpr.Val + max(0, lmax_sum_b) + max(0, rmax_sum_b)
       bpr.MaxSum_b = bpr.Val + max(0, max(lmax_sum_b, rmax_sum_b))

       return bpr.MaxSum_b
     }
   #+END_SRC

   #+BEGIN_SRC go :imports "fmt" :noweb strip-export
     <<max-path-sum>>
     func main() {
       root := &TreeNode{
         Val: 1,
         Left: &TreeNode{
           Val: 2,
         },
         Right: &TreeNode{
           Val: 3,
         },
       }

       fmt.Println(maxPathSum(root))
     }
   #+END_SRC

   #+RESULTS:
   : 3
** sum root to leaf numbers
   #+NAME: sum-numbers
   #+BEGIN_SRC go
     type TreeNode struct {
       Val   int
       Left  *TreeNode
       Right *TreeNode
     }

     func sumNumbers(root *TreeNode) int {
       path_arr := collectPath(root)

       var sum int
       for index, _ := range path_arr {
         path := path_arr[index]
         var sub_sum int
         for _, num := range path {
           sub_sum = num + sub_sum*10
         }
         sum += sub_sum
       }

       return sum
     }

     func collectPath(root *TreeNode) [][]int {
       if root == nil {
         return [][]int{}
       }

       if root.Left == nil && root.Right == nil {
         return [][]int{
           []int{root.Val},
         }
       }

       lpath_arr := collectPath(root.Left)
       rpath_arr := collectPath(root.Right)
       lpath_arr = append(lpath_arr, rpath_arr...)
       for index, _ := range lpath_arr {
         path := lpath_arr[index]
         path = append([]int{root.Val}, path...)
         lpath_arr[index] = path
       }
       return lpath_arr
     }
   #+END_SRC

   #+BEGIN_SRC go :imports "fmt" :noweb strip-export
     <<sum-numbers>>
     func main() {
       root := &TreeNode{
         Val: 1,
         Left: &TreeNode{
           Val: 2,
         },
         Right: &TreeNode{
           Val: 3,
         },
       }

       fmt.Println(sumNumbers(root))
     }

   #+END_SRC
* poor pigs
  #+BEGIN_SRC go
    func poorPigs(buckets int, minutesToDie int, minutesToTest int) int {
      time := minutesToTest/minutesToDie + 1
      res := 0
      for {
        if int(math.Pow(float64(time), float64(res))) < buckets {
          res = res + 1
        } else {
          break
        }
      }

      return res
    }
  #+END_SRC
* binary tree traversal
** level order
  #+NAME: bt-level-order
  #+BEGIN_SRC go
    type TreeNode struct {
      Val   int
      Left  *TreeNode
      Right *TreeNode
    }

    func levelOrder(root *TreeNode) [][]int {
      if root == nil {
        return [][]int{}
      }

      lo_arr := [][]int{
        []int{root.Val},
      }

      llo_arr := levelOrder(root.Left)
      rlo_arr := levelOrder(root.Right)

      if len(llo_arr) > 0 || len(rlo_arr) > 0 {
        var index int
        for {
          if index < len(llo_arr) && index < len(rlo_arr) {
            lo_arr = append(lo_arr, append(llo_arr[index], rlo_arr[index]...))
          } else {
            break
          }
          index += 1
        }

        if len(llo_arr) > index {
          lo_arr = append(lo_arr, llo_arr[index:]...)
        }

        if len(rlo_arr) > index {
          lo_arr = append(lo_arr, rlo_arr[index:]...)
        }
      }

      return lo_arr
    }
  #+END_SRC

  #+BEGIN_SRC go :imports "fmt" :noweb strip-export
     <<bt-level-order>>
     func main() {
       root := &TreeNode{
         Val: 1,
         Left: &TreeNode{
           Val: 2,
         },
         Right: &TreeNode{
           Val: 3,
         },
       }

       fmt.Println(levelOrder(root))
       root.Left.Left = &TreeNode{Val:4}
       root.Right.Right = &TreeNode{Val:5}
       fmt.Println(levelOrder(root))
     }

   #+END_SRC

   #+RESULTS:
   : [[1] [2 3]]
** level order bottom
   #+NAME: bt-level-order-bottom
   #+BEGIN_SRC go :noweb stip-export :main no
     <<bt-level-order>>
     func levelOrderBottom(root *TreeNode) [][]int {
       lo_arr := levelOrder(root)
       lob_arr := make([][]int, 0)
       for index, _ := range lo_arr {
         lob_arr = append([][]int{lo_arr[index]}, lob_arr...)
       }

       return lob_arr
     }
   #+END_SRC

   #+BEGIN_SRC go :imports "fmt" :noweb strip-export
     <<bt-level-order-bottom>>
     func main() {
       root := &TreeNode{
         Val: 1,
         Left: &TreeNode{
           Val: 2,
         },
         Right: &TreeNode{
           Val: 3,
         },
       }

       fmt.Println(levelOrderBottom(root))
       root.Left.Left = &TreeNode{Val:4}
       root.Right.Right = &TreeNode{Val:5}
       fmt.Println(levelOrderBottom(root))
     }
   #+END_SRC
** zigzag level order
  #+NAME: bt-zigzag-level-order
  #+BEGIN_SRC go
      <<bt-level-order>>
      func zigzagLevelOrder(root *TreeNode) [][]int {
      lo_arr := levelOrder(root)
      zlo_arr := make([][]int, 0)
      for index, _ := range lo_arr {
        lo := lo_arr[index]
        if index % 2 == 1 {
          zlo := make([]int, 0)
          for index, _ := range lo {
            zlo = append([]int{lo[index]}, zlo...)
          }
          zlo_arr = append(zlo_arr, zlo)
        } else {
          zlo_arr = append(zlo_arr, lo)
        }
      }

      return zlo_arr
    }
  #+END_SRC

  #+BEGIN_SRC go :imports "fmt" :noweb strip-export
     <<bt-zigzag-level-order>>
     func main() {
       root := &TreeNode{
         Val: 1,
         Left: &TreeNode{
           Val: 2,
         },
         Right: &TreeNode{
           Val: 3,
         },
       }

       fmt.Println(zigzagLevelOrder(root))
       root.Left.Left = &TreeNode{Val:4}
       root.Right.Right = &TreeNode{Val:5}
       fmt.Println(zigzagLevelOrder(root))
     }

   #+END_SRC

   #+RESULTS:
   : [[1] [3 2]]
   : [[1] [3 2] [4 5]]
** inOrder
   #+NAME: bt-inorder-traver
   #+BEGIN_SRC go
     type TreeNode struct {
       Val   int
       Left  *TreeNode
       Right *TreeNode
     }

     func inorderTraversal(root *TreeNode) []int {
       if root == nil {
         return []int{}
       }

       return append(
         append(inorderTraversal(root.Left), root.Val),
         inorderTraversal(root.Right)...)
     }
   #+END_SRC

   #+BEGIN_SRC go :imports "fmt" :noweb strip-export
     <<bt-inorder-traver>>
     func main() {
       root := &TreeNode{
         Val: 1,
         Left: &TreeNode{
           Val: 2,
         },
         Right: &TreeNode{
           Val: 3,
         },
       }

       fmt.Println(inorderTraversal(root))
       root.Left.Left = &TreeNode{Val:4}
       root.Right.Right = &TreeNode{Val:5}
       fmt.Println(inorderTraversal(root))
     }
   #+END_SRC
** preOrder
   #+NAME: bt-preorder-traver
   #+BEGIN_SRC go
     type TreeNode struct {
       Val   int
       Left  *TreeNode
       Right *TreeNode
     }

     func preorderTraversal(root *TreeNode) []int {
       if root == nil {
         return []int{}
       }

       return append(
         append([]int{root.Val}, preorderTraversal(root.Left)...),
         preorderTraversal(root.Right)...)
     }
   #+END_SRC

   #+BEGIN_SRC go :imports "fmt" :noweb strip-export
     <<bt-preorder-traver>>
     func main() {
       root := &TreeNode{
         Val: 1,
         Left: &TreeNode{
           Val: 2,
         },
         Right: &TreeNode{
           Val: 3,
         },
       }

       fmt.Println(preorderTraversal(root))
       root.Left.Left = &TreeNode{Val:4}
       root.Right.Right = &TreeNode{Val:5}
       fmt.Println(preorderTraversal(root))
     }
   #+END_SRC
** postOrder
   #+NAME: bt-postorder-traver
   #+BEGIN_SRC go
     type TreeNode struct {
       Val   int
       Left  *TreeNode
       Right *TreeNode
     }

     func postorderTraversal(root *TreeNode) []int {
       if root == nil {
         return []int{}
       }

       return append(
         append(postorderTraversal(root.Left), postorderTraversal(root.Right)...),
         root.Val)
     }
   #+END_SRC

   #+BEGIN_SRC go :imports "fmt" :noweb strip-export
     <<bt-postorder-traver>>
     func main() {
       root := &TreeNode{
         Val: 1,
         Left: &TreeNode{
           Val: 2,
         },
         Right: &TreeNode{
           Val: 3,
         },
       }

       fmt.Println(postorderTraversal(root))
       root.Left.Left = &TreeNode{Val:4}
       root.Right.Right = &TreeNode{Val:5}
       fmt.Println(postorderTraversal(root))
     }
   #+END_SRC

* binary tree
  #+NAME: bt-node-def
  #+BEGIN_SRC go
    type TreeNode struct {
      Val   int
      Left  *TreeNode
      Right *TreeNode
    }
  #+END_SRC
** max depth
   #+NAME: bt-max-depth
   #+BEGIN_SRC go
     type TreeNode struct {
       Val   int
       Left  *TreeNode
       Right *TreeNode
     }

     func max(a, b int) int {
       if a > b {
         return a
       } else {
         return b
       }
     }

     func maxDepth(root *TreeNode) int {
       if root == nil {
         return 0
       }

       return 1 + max(maxDepth(root.Left), maxDepth(root.Right))
     }
   #+END_SRC

   #+BEGIN_SRC go :imports "fmt" :noweb strip-export
     <<bt-max-depth>>
     func main() {
       root := &TreeNode{
         Val: 1,
         Left: &TreeNode{
           Val: 2,
         },
         Right: &TreeNode{
           Val: 3,
         },
       }

       fmt.Println(maxDepth(root))
       root.Left.Left = &TreeNode{Val:4}
       root.Right.Right = &TreeNode{Val:5}
       fmt.Println(maxDepth(root))
     }
   #+END_SRC
** paths
   #+NAME: bt-paths
   #+BEGIN_SRC go
     type TreeNode struct {
       Val   int
       Left  *TreeNode
       Right *TreeNode
     }

     func binaryTreePaths(root *TreeNode) []string {
       if root == nil {
         return []string{}
       }

       str := fmt.Sprintf("%d", root.Val)
       if root.Left == nil && root.Right == nil {
         return []string{str}
       }

       paths := append(
         binaryTreePaths(root.Left),
         binaryTreePaths(root.Right)...,
       )
       for index, path := range paths {
         paths[index] = str + "->" + path
       }

       return paths
     }
   #+END_SRC

   #+BEGIN_SRC go :imports "fmt" :noweb strip-export
     <<bt-paths>>
     func main() {
       root := &TreeNode{
         Val: 1,
         Left: &TreeNode{
           Val: 2,
         },
         Right: &TreeNode{
           Val: 3,
         },
       }

       fmt.Println(binaryTreePaths(root))
       root.Left.Left = &TreeNode{Val:4}
       root.Right.Right = &TreeNode{Val:5}
       fmt.Println(binaryTreePaths(root))
     }
   #+END_SRC
** isBalanced
   #+NAME: bt-is-balanced
   #+BEGIN_SRC go
     <<bt-max-depth>>
     func isBalanced(root *TreeNode) bool {
       if root == nil {
         return true
       }

       ldepth := maxDepth(root.Left)
       rdepth := maxDepth(root.Right)
       ddepth := ldepth - rdepth
       if ddepth > 1 || ddepth < -1 {
         return false
       }

       return isBalanced(root.Left) && isBalanced(root.Right)
     }
   #+END_SRC

   #+BEGIN_SRC go :imports "fmt" :noweb strip-export
     <<bt-is-balanced>>
     func main() {
       root := &TreeNode{
         Val: 1,
         Left: &TreeNode{
           Val: 2,
         },
       }

       fmt.Println(isBalanced(root))
       root.Left.Left = &TreeNode{Val:4}
       fmt.Println(isBalanced(root))
     }
   #+END_SRC

   #+RESULTS:
   : true
   : true
** invert
   #+NAME: bt-invert
   #+BEGIN_SRC go
     type TreeNode struct {
       Val   int
       Left  *TreeNode
       Right *TreeNode
     }

     func invertTree(root *TreeNode) *TreeNode {
       if root == nil {
         return nil
       }

       root.Left, root.Right = invertTree(root.Right), invertTree(root.Left)
       return root
     }
   #+END_SRC

   #+BEGIN_SRC go :imports "fmt" :noweb strip-export
     <<bt-invert>>
     func main() {
       root := &TreeNode{
         Val: 1,
         Left: &TreeNode{
           Val: 2,
         },
         Right: &TreeNode{
           Val: 3,
         },
       }

       fmt.Println(invertTree(root))
       root.Left.Left = &TreeNode{Val:4}
       root.Right.Right = &TreeNode{Val:5}
       fmt.Println(invertTree(root))
     }
   #+END_SRC
** tilt
   #+NAME: bt-tilt
   #+BEGIN_SRC go
     type TreeNode struct {
       Val   int
       Left  *TreeNode
       Right *TreeNode
     }

     func sumTree(root *TreeNode) int {
       if root == nil {
         return 0
       }

       return root.Val + sumTree(root.Left) + sumTree(root.Right)
     }

     func abs(num int) int {
       if num < 0 {
         return -num
       } else {
         return num
       }
     }

     func findTilt(root *TreeNode) int {
       if root == nil {
         return 0
       }

       return abs(sumTree(root.Left)-sumTree(root.Right)) +
         findTilt(root.Left) + findTilt(root.Right)
     }
   #+END_SRC

   #+BEGIN_SRC go :imports "fmt" :noweb strip-export
     <<bt-tilt>>
     func main() {
       root := &TreeNode{
         Val: 1,
         Left: &TreeNode{
           Val: 2,
         },
         Right: &TreeNode{
           Val: 3,
         },
       }

       fmt.Println(findTilt(root))
       root.Left.Left = &TreeNode{Val:4}
       root.Right.Right = &TreeNode{Val:5}
       fmt.Println(findTilt(root))
     }
   #+END_SRC

   #+RESULTS:
   : 1
   : 11
** construct string
   #+NAME: bt-construct-string
   #+BEGIN_SRC go
     func tree2str(t *TreeNode) string {
       if t == nil {
         return ""
       }

       str := fmt.Sprintf("%d", t.Val)
       if t.Left == nil && t.Right == nil {
         return str
       }

       if t.Left != nil {
         str += fmt.Sprintf("(%s)", tree2str(t.Left))
       } else {
         str += "()"
       }

       if t.Right != nil {
         str += fmt.Sprintf("(%s)", tree2str(t.Right))
       }

       return str
     }
   #+END_SRC
** symmetric
   #+NAME: bt-is-symmetric
   #+BEGIN_SRC go
     type TreeNode struct {
       Val   int
       Left  *TreeNode
       Right *TreeNode
     }

     func isSymmetric(root *TreeNode) bool {
       if root == nil {
         return true
       }

       return isMirror(root.Left, root.Right)
     }

     func isMirror(lr *TreeNode, rr *TreeNode) bool {
       if lr == nil && rr == nil {
         return true
       }

       if lr == nil || rr == nil {
         return false
       }

       if lr.Val != rr.Val {
         return false
       }

       return isMirror(lr.Left, rr.Right) && isMirror(lr.Right, rr.Left)
     }
   #+END_SRC

   #+BEGIN_SRC go :imports "fmt" :noweb strip-export
     <<bt-is-symmetric>>

     func main() {
       root := &TreeNode{
         Val: 1,
         Left: &TreeNode{
           Val: 2,
         },
         Right: &TreeNode{
           Val: 2,
         },
       }

       fmt.Println(isSymmetric(root))
       root.Left.Left = &TreeNode{Val:4}
       root.Right.Right = &TreeNode{Val:5}
       fmt.Println(isSymmetric(root))
     }
   #+END_SRC

   #+RESULTS:
   : true
   : false
** subtree
   #+NAME: bt-subtree
   #+BEGIN_SRC  go
     type TreeNode struct {
       Val   int
       Left  *TreeNode
       Right *TreeNode
     }

     func isSubtree(s *TreeNode, t *TreeNode) bool {
       if t == nil {
         return true
       }

       if s == nil {
         return false
       }

       if s.Val == t.Val {
         return isSame(s, t) || isSubtree(s.Left, t) || isSubtree(s.Right, t)
       } else {
         return isSubtree(s.Left, t) || isSubtree(s.Right, t)

       }
     }

     func isSame(s *TreeNode, t *TreeNode) bool {
       if s == nil && t == nil {
         return true
       }

       if s == nil || t == nil {
         return false
       }

       if s.Val != t.Val {
         return false
       }

       return isSame(s.Left, t.Left) && isSame(s.Right, t.Right)
     }
   #+END_SRC

   #+BEGIN_SRC go :imports "fmt" :noweb strip-export
     <<bt-subtree>>

     func main() {
       s := &TreeNode{
         Val: 1,
         Left: &TreeNode{
           Val: 4,
           Left: &TreeNode{
             Val: 1,
           },
           Right: &TreeNode{
             Val: 2,
           },
         },
         Right: &TreeNode{
           Val: 5,
         },
       }

       t := &TreeNode{
         Val: 4,
         Left: &TreeNode{
           Val: 1,
         },
         Right: &TreeNode{
           Val: 2,
         },
       }

       fmt.Println(isSubtree(s, t))
       s.Left.Right = &TreeNode{
         Val: 0,
       }
       fmt.Println(isSubtree(s, t))
     }
   #+END_SRC

   #+RESULTS:
   : true
** diameter
   #+NAME: bt-diameter
   #+BEGIN_SRC go
     type TreeNode struct {
       Val   int
       Left  *TreeNode
       Right *TreeNode
     }

     func diameterOfBinaryTree(root *TreeNode) int {
       if root == nil {
         return 0
       }

       if root.Left == nil && root.Right == nil {
         return 0
       }

       if root.Right == nil {
         return max(1+maxSide(root.Left), diameterOfBinaryTree(root.Left))
       }

       if root.Left == nil {
         return max(1+maxSide(root.Right), diameterOfBinaryTree(root.Right))
       }

       return max(
         max(
           (2+maxSide(root.Left)+maxSide(root.Right)),
           diameterOfBinaryTree(root.Left),
         ), diameterOfBinaryTree(root.Right))
     }

     func maxSide(root *TreeNode) int {
       if root == nil {
         return 0
       }

       if root.Left == nil && root.Right == nil {
         return 0
       }

       return 1 + max(maxSide(root.Left), maxSide(root.Right))
     }

     func max(a, b int) int {
       if a > b {
         return a
       } else {
         return b
       }
     }
   #+END_SRC

   #+BEGIN_SRC go :imports "fmt" :noweb strip-export
     <<bt-diameter>>

     func main() {
       s := &TreeNode{
         Val: 1,
         Left: &TreeNode{
           Val: 4,
           Left: &TreeNode{
             Val: 1,
           },
           Right: &TreeNode{
             Val: 2,
           },
         },
         Right: &TreeNode{
           Val: 5,
         },
       }

       t := &TreeNode{
         Val: 4,
         Left: &TreeNode{
           Val: 1,
         },
         Right: &TreeNode{
           Val: 2,
         },
       }

       fmt.Println(diameterOfBinaryTree(s))
       fmt.Println(diameterOfBinaryTree(t))
     }
   #+END_SRC

   #+RESULTS:
   : 2
   : 1
** count complete tree nodes
   #+NAME: bt-count-complete
   #+BEGIN_SRC c++
     struct TreeNode {
         int val;
         TreeNode *left;
         TreeNode *right;
         TreeNode(int x) : val(x), left(NULL), right(NULL) {}
     };

     class Solution {
     public:
       int countNodes(TreeNode* root) {
         if (root == NULL) {
           return 0;
         }

         int ldepth = this->getLeftDepth(root);
         int rdepth = this->getRightDepth(root);
         if (ldepth == rdepth) {
           return this->pow(2,ldepth) -1;
         }

         return countNodes(root->left) + countNodes(root->right)+1;
       }

       int getLeftDepth(TreeNode *root) {
         if (root == NULL) {
           return 0;
         }

         return 1+getLeftDepth(root->left);
       }

       int getRightDepth(TreeNode *root) {
         if (root == NULL) {
           return 0;
         }

         return 1+getRightDepth(root->right);
       }

       int pow(int base, int exp) {
         int p=1;
         while (exp>0) {
           p = p*base;
           exp = exp- 1;
         }

         return p;
       }
     };
   #+END_SRC

   #+BEGIN_SRC C++ :includes <iostream>  :noweb strip-export :results output
   <<bt-count-complete>>
   int main() {
     TreeNode* p = new TreeNode(5);
     p->left = new TreeNode(3);
     p->right = new TreeNode(7);

     Solution s;
     std::cout << s.countNodes(p);
   }
   #+END_SRC

   #+RESULTS:
   : 3
** implement trie
   #+NAME: imp-trie
   #+BEGIN_SRC go
     type Trie struct {
       is_end int
       next   map[byte]*Trie
     }

     /** Initialize your data structure here. */
     func Constructor() Trie {
       var trie Trie
       trie.next = make(map[byte]*Trie)
       return trie
     }

     /** Inserts a word into the trie. */
     func (this *Trie) Insert(word string) {
       byte_arr := []byte(word)
       this.insert(byte_arr)
     }

     func (this *Trie) insert(byte_arr []byte) {
       if len(byte_arr) < 1 {
         return
       }

       if next_trie, ok := this.next[byte_arr[0]]; ok {
         if len(byte_arr) > 1 {
           next_trie.insert(byte_arr[1:])
         } else {
           next_trie.is_end = 1
         }
       } else {
         trie := Constructor()
         next_trie := &trie
         this.next[byte_arr[0]] = next_trie
         if len(byte_arr) > 1 {
           next_trie.insert(byte_arr[1:])
         } else {
           next_trie.is_end = 1
         }
       }
     }

     /** Returns if the word is in the trie. */
     func (this *Trie) Search(word string) bool {
       byte_arr := []byte(word)
       return this.search(byte_arr)
     }

     func (this *Trie) search(byte_arr []byte) bool {
       if len(byte_arr) < 1 {
         if len(this.next) == 0 {
           return true
         } else {
           return false
         }
       }

       if next_trie, ok := this.next[byte_arr[0]]; ok {
         if len(byte_arr) == 1 && next_trie.is_end == 1 {
           return true
         } else {
           return next_trie.search(byte_arr[1:])
         }
       } else {
         return false
       }
     }

     /** Returns if there is any word in the trie that starts with the given prefix. */
     func (this *Trie) StartsWith(prefix string) bool {
       byte_arr := []byte(prefix)
       return this.startsWith(byte_arr)
     }

     func (this *Trie) startsWith(byte_arr []byte) bool {
       if len(byte_arr) < 1 {
         return true
       }

       if next_trie, ok := this.next[byte_arr[0]]; ok {
         return next_trie.startsWith(byte_arr[1:])
       } else {
         return false
       }
     }

     /**
      ,* Your Trie object will be instantiated and called as such:
      ,* obj := Constructor();
      ,* obj.Insert(word);
      ,* param_2 := obj.Search(word);
      ,* param_3 := obj.StartsWith(prefix);
      ,*/
   #+END_SRC

   #+BEGIN_SRC go :imports "fmt" :noweb strip-export
     <<imp-trie>>

     func main() {
       trie := Constructor()
       trie.Insert("hello")
       fmt.Println(trie.Search("hello"))
       fmt.Println(trie.StartsWith("hello"))
     }
   #+END_SRC
** merge two binary tree
   #+NAME: merge-two-bt
   #+BEGIN_SRC go
     func mergeTrees(t1 *TreeNode, t2 *TreeNode) *TreeNode {
       if t1 == nil && t2 == nil {
         return nil
       }

       if t2 == nil {
         return &TreeNode{
           Val:   t1.Val,
           Left:  mergeTrees(t1.Left, nil),
           Right: mergeTrees(t1.Right, nil),
         }
       }

       if t1 == nil {
         return &TreeNode{
           Val:   t2.Val,
           Left:  mergeTrees(nil, t2.Left),
           Right: mergeTrees(nil, t2.Right),
         }
       }

       return &TreeNode{
         Val:   t1.Val + t2.Val,
         Left:  mergeTrees(t1.Left, t2.Left),
         Right: mergeTrees(t1.Right, t2.Right),
       }
     }
   #+END_SRC

   #+BEGIN_SRC go :imports "fmt" :noweb strip-export
     <<bt-node-def>>

     <<bt-construct-string>>

     <<merge-two-bt>>

     func main() {
       t1 := &TreeNode{
         Val: 1,
         Left: &TreeNode{Val: 3},
       }

       t2 := &TreeNode{
         Val: 2,
         Right: &TreeNode{Val: 3},
       }

       fmt.Println(tree2str(mergeTrees(t1, t2)))
     }
   #+END_SRC

   #+RESULTS:
   : 3(3)(3)

* BST
** BSTIterator
 #+NAME: bst-iterator
 #+BEGIN_SRC C++
   /**
    ,* Definition for binary tree
    ,* struct TreeNode {
    ,*     int val;
    ,*     TreeNode *left;
    ,*     TreeNode *right;
    ,*     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
    ,* };
    ,*/

   struct TreeNode {
     int val;
     TreeNode *left;
     TreeNode *right;
     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
   };

   struct Node {
     int val;
     Node *next;
     Node(int x) : val(x), next(NULL) {}
   };

   Node* convertBST2SortedLst(TreeNode *lct,TreeNode *pn, TreeNode *rct) {
     Node *lhead = NULL;
     if (lct != NULL) {
       lhead = convertBST2SortedLst(lct->left, lct, lct->right);
     }

     Node *pln = new Node(pn->val);

     Node *rhead = NULL;
     if (rct != NULL){
       rhead = convertBST2SortedLst(rct->left, rct, rct->right);
     }

     Node *head = NULL;
     if (lhead != NULL) {
       pln->next = rhead;
       head = lhead;
       while (lhead->next != NULL) {
         lhead = lhead->next;
       }
       lhead->next = pln;
     } else {
       pln->next = rhead;
       head = pln;
     }
     return head;
   }

   class BSTIterator {
     Node* head;
   public:
     BSTIterator(TreeNode *root) {
       if (root != NULL) {
         head = convertBST2SortedLst(root->left, root, root->right);
       } else {
         head = NULL;
       }
     }

     /** @return whether we have a next smallest number */
     bool hasNext() {
       if (this->head != NULL) {
         return true;
       } else {
         return false;
       }
     }

     /** @return the next smallest number */
     int next() {
       if (this->head== NULL) {
         return 0;
       }

       Node *oldHead = head;
       head = head->next;
       int num = oldHead->val;
       delete oldHead;
       oldHead = NULL;
       return num;
     }

     ~BSTIterator(){
       Node *oldHead = NULL;
       while (head != NULL){
         oldHead = head;
         head = head->next;
         delete oldHead;
         oldHead = NULL;
       }
     }
   };

   /**
    ,* Your BSTIterator will be called like this:
    ,* BSTIterator i = BSTIterator(root);
    ,* while (i.hasNext()) cout << i.next();
    ,*/
 #+END_SRC

 #+BEGIN_SRC C++ :includes <iostream>  :noweb strip-export :results output
   <<bst-iterator>>
   int main() {
     TreeNode* p = new TreeNode(5);
     p->left = new TreeNode(3);
     p->right = new TreeNode(7);

     BSTIterator i = BSTIterator(p);
     while (i.hasNext())
       std::cout << i.next();
     return 0;
   }
 #+END_SRC

 #+RESULTS:
** to greater tree
   #+NAME: bst-to-greater
   #+BEGIN_SRC go
     type TreeNode struct {
       Val   int
       Left  *TreeNode
       Right *TreeNode
     }

     func convertBST(root *TreeNode) *TreeNode {
       if root == nil {
         return nil
       }

       return convertBSTHelper(root, 0)
     }

     func convertBSTHelper(root *TreeNode, upper int) *TreeNode {
       if root == nil {
         return nil
       }

       if root.Left == nil && root.Right == nil {
         root.Val += upper
         return root
       }

       if root.Right != nil {
         minNode := findMinBST(root.Right)
         root.Right = convertBSTHelper(root.Right, upper)
         root.Val += minNode.Val
       } else {
         root.Val += upper
       }

       if root.Left != nil {
         root.Left = convertBSTHelper(root.Left, root.Val)
       }

       return root
     }

     func findMinBST(root *TreeNode) *TreeNode {
       if root == nil || root.Left == nil {
         return root
       }

       return findMinBST(root.Left)
     }
   #+END_SRC

   #+BEGIN_SRC go :imports "fmt" :noweb strip-export
     <<bst-to-greater>>

     func main() {
       root := &TreeNode{
         Val: 0,
         Left: &TreeNode{
           Val: -1,
           Left: &TreeNode{
             Val: -3,
           },
         },
         Right: &TreeNode{
           Val: 2,
           Right: &TreeNode{
             Val: 4,
           },
         },
       }

       fmt.Println(convertBST(root))
       fmt.Println(root.Left)
       fmt.Println(root.Left.Left)
       fmt.Println(root.Right.Right)
     }
   #+END_SRC
** validate
   #+NAME: bst-validate
   #+BEGIN_SRC go
     type TreeNode struct {
       Val   int
       Left  *TreeNode
       Right *TreeNode
     }

     func isValidBST(root *TreeNode) bool {
       if root == nil {
         return true
       }

       return isValidLeftBST(root.Left, root.Val) && isValidRightBST(root.Right, root.Val)
     }

     func isValidLeftBST(root *TreeNode, upper int) bool {
       if root == nil {
         return true
       }

       if root.Val >= upper {
         return false
       }

       return isValidLeftBST(root.Left, root.Val) && isValidSubBST(root.Right, root.Val, upper)
     }

     func isValidRightBST(root *TreeNode, lower int) bool {
       if root == nil {
         return true
       }

       if root.Val <= lower {
         return false
       }

       return isValidRightBST(root.Right, root.Val) && isValidSubBST(root.Left, lower, root.Val)
     }

     func isValidSubBST(root *TreeNode, lower int, upper int) bool {
       if root == nil {
         return true
       }

       if root.Val >= upper || root.Val <= lower {
         return false
       }

       return isValidSubBST(root.Left, lower, root.Val) && isValidSubBST(root.Right, root.Val, upper)
     }
   #+END_SRC

   #+BEGIN_SRC go :imports "fmt" :noweb strip-export
     <<bst-validate>>
     func main() {
       root := &TreeNode{
         Val: 1,
         Left: &TreeNode{
           Val: 2,
         },
         Right: &TreeNode{
           Val: 3,
         },
       }

       fmt.Println(isValidBST(root))

       root = &TreeNode{
         Val: 2,
         Left: &TreeNode{
           Val: 1,
         },
         Right: &TreeNode{
           Val: 3,
         },
       }
       fmt.Println(isValidBST(root))
     }
   #+END_SRC

   #+RESULTS:
   : false
   : true
** find mode
   #+NAME: bst-find-mode
   #+BEGIN_SRC go
     type TreeNode struct {
       Val   int
       Left  *TreeNode
       Right *TreeNode
     }

     func findMode(root *TreeNode) []int {
       if root == nil {
         return []int{}
       }

       modes := collect(root)
       if len(modes) < 1 {
         return modes
       }

       for i := 1; i < len(modes); i += 1 {
         for j := i; j > 0; j -= 1 {
           if modes[j] < modes[j-1] {
             modes[j], modes[j-1] = modes[j-1], modes[j]
           }
         }
       }

       var max_count int
       var count int
       var pre int
       n_modes := make([]int, 0)
       for index, mode := range modes {
         if index == 0 {
           max_count = 1
           pre = mode
           count = 1
           n_modes = append(n_modes, mode)
           continue
         }

         if mode == pre {
           count += 1
         }

         if mode != pre {
           pre = mode
           count = 1
         }

         if count == max_count {
           n_modes = append(n_modes, mode)
         }
         if count > max_count {
           max_count = count
           n_modes = []int{mode}
         }
       }

       return n_modes
     }

     func collect(root *TreeNode) []int {
       if root == nil {
         return []int{}
       }

       return append(append(collect(root.Left), root.Val), collect(root.Right)...)
     }
   #+END_SRC

   #+BEGIN_SRC go :imports "fmt" :noweb strip-export
     <<bst-find-mode>>

     func main() {
       root := &TreeNode{
         Val: 0,
         Left: &TreeNode{
           Val: -1,
           Left: &TreeNode{
             Val: -1,
           },
         },
         Right: &TreeNode{
           Val: 2,
           Right: &TreeNode{
             Val: 2,
           },
         },
       }

       fmt.Println(findMode(root))
     }
   #+END_SRC

   #+RESULTS:
   : [-1 -1 0 2 2]
   : [-1 -1 0 2 2]
   : [-1]
** convert sorted array to bst
   #+NAME: sorted-array-to-bst
   #+BEGIN_SRC go
     func sortedArrayToBST(nums []int) *TreeNode {
       if len(nums) == 0 {
         return nil
       }

       if len(nums) == 1 {
         return &TreeNode{
           Val: nums[0],
         }
       }

       if len(nums) == 2 {
         return &TreeNode{
           Val: nums[1],
           Left: &TreeNode{
             Val: nums[0],
           },
         }
       }

       mid := len(nums) / 2
       return &TreeNode{
         Val:   nums[mid],
         Left:  sortedArrayToBST(nums[:mid]),
         Right: sortedArrayToBST(nums[mid+1:]),
       }
     }
   #+END_SRC

   #+BEGIN_SRC go :imports "fmt" :noweb strip-export
     <<bt-construct-string>>

     <<sorted-array-to-bst>>

     func main() {
       fmt.Println(tree2str(sortedArrayToBST([]int{1,2,3})))
       fmt.Println(tree2str(sortedArrayToBST([]int{1,2,3,4,5,6})))
       fmt.Println(tree2str(sortedArrayToBST([]int{1,2,3,4,5,6,7,8})))
     }
   #+END_SRC

   #+RESULTS:
   : 2(1)(3(2))
   : 4(2(1)(3(2)))(5(4)(6(5)))
   : 5(3(2(1))(4(3)))(7(6(5))(8(7)))
** lowest common ancestor
   #+NAME: bst-lca
   #+BEGIN_SRC c++
     struct TreeNode {
       int val;
       TreeNode *left;
       TreeNode *right;
       TreeNode(int x) : val(x), left(NULL), right(NULL) {}
     };

     class Solution {
     public:
       TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
         if (root == NULL) {
           return NULL;
         }

         if (p->val > q->val) {
           TreeNode *tmp = p;
           p=q;
           q=tmp;
         }

         if (root->val>p->val && root->val<q->val) {
           return root;
         }

         if (root->val < p->val) {
           return lowestCommonAncestor(root->right, p, q);
         }

         if (root->val > q->val) {
           return lowestCommonAncestor(root->left, p, q);
         }

         if (root->val == p->val) {
           return root;
         }

         if (root->val == q->val) {
           return root;
         }

         return NULL;
       }
     };
   #+END_SRC

   #+BEGIN_SRC C++ :includes <iostream>  :noweb strip-export :results output
     <<bst-lca>>

     int main() {
       TreeNode* p = new TreeNode(5);
       p->left = new TreeNode(3);
       p->right = new TreeNode(7);

       Solution  s;
       std::cout << s.lowestCommonAncestor(p, p->left, p->right)->val;
     }
   #+END_SRC

   #+RESULTS:
   : 5
** recover binary search tree
   #+NAME: recover-bst
   #+BEGIN_SRC go
     type TreeNode struct {
       Val   int
       Left  *TreeNode
       Right *TreeNode
     }

     type RecoverNode struct {
       Pre        *TreeNode
       Ppre       *TreeNode
       Is_recover int
       Illegal    *TreeNode
     }

     type traversalFunc func(*TreeNode)

     func recoverTree(root *TreeNode) {
       if root == nil {
         return
       }

       rNode := &RecoverNode{}
       tfunc := func(rnode *RecoverNode) traversalFunc {
         return func(node *TreeNode) {
           recoverFunc(node, rnode)
         }
       }(rNode)
       inorderTraversal(root, tfunc)
       if rNode.Is_recover == 0 && rNode.Illegal != nil {
         rNode.Pre.Val, rNode.Illegal.Val = rNode.Illegal.Val, rNode.Pre.Val
       }
     }

     func inorderTraversal(root *TreeNode, tfunc traversalFunc) {
       if root == nil {
         return
       }

       inorderTraversal(root.Left, tfunc)
       tfunc(root)
       inorderTraversal(root.Right, tfunc)
     }

     func recoverFunc(node *TreeNode, rnode *RecoverNode) {
       if node == nil {
         return
       }

       if rnode.Is_recover == 1 {
         return
       }

       if rnode.Pre == nil {
         rnode.Pre = node
         return
       }

       if node.Val < rnode.Pre.Val {
         if rnode.Illegal == nil {
           rnode.Illegal = rnode.Pre
         } else {
           rnode.Illegal.Val, node.Val = node.Val, rnode.Illegal.Val
           rnode.Is_recover = 1
         }
       } else {
         if rnode.Illegal != nil {
           if rnode.Illegal.Val < node.Val {
             rnode.Illegal.Val, rnode.Pre.Val = rnode.Pre.Val, rnode.Illegal.Val
             rnode.Is_recover = 1
           }
         }
       }

       rnode.Ppre = rnode.Pre
       rnode.Pre = node
     }
   #+END_SRC

   #+BEGIN_SRC go :imports "fmt" :noweb strip-export
     <<recover-bst>>

     <<bt-construct-string>>

     func main() {
       s := &TreeNode{
         Val: 2,
         Left: &TreeNode{
           Val: 3,
         },
         Right: &TreeNode{
           Val: 1,
         },
       }

       fmt.Println(tree2str(s))
       recoverTree(s)
       fmt.Println(tree2str(s))
     }
   #+END_SRC

   #+RESULTS:
   : 2(3)(1)
   : 2(1)(3)
** delete node
   #+NAME: bst-delete-node
   #+BEGIN_SRC go
     type TreeNode struct {
       Val   int
       Left  *TreeNode
       Right *TreeNode
     }

     func deleteNode(root *TreeNode, key int) *TreeNode {
       if root == nil {
         return nil
       }

       if root.Val == key {
         if root.Left == nil || root.Right == nil {
           if root.Left != nil {
             return root.Left
           } else if root.Right != nil {
             return root.Right
           } else {
             return nil
           }
         } else {
           successor := treeMinimum(root.Right)
           root.Val = successor.Val
           root.Right = deleteNode(root.Right, successor.Val)
         }
       }

       if root.Val < key {
         root.Right = deleteNode(root.Right, key)
       } else {
         root.Left = deleteNode(root.Left, key)
       }
       return root
     }

     func treeMinimum(node *TreeNode) *TreeNode {
       if node.Left != nil {
         return treeMinimum(node.Left)
       } else {
         return node
       }
     }
   #+END_SRC

   #+BEGIN_SRC go :imports "fmt" :noweb strip-export
     <<bst-delete-node>>

     <<bt-construct-string>>

     func main() {
       s := &TreeNode{
         Val: 2,
         Left: &TreeNode{
           Val: 1,
         },
         Right: &TreeNode{
           Val: 3,
         },
       }

       fmt.Println(tree2str(s))
       s = deleteNode(s, 1)
       fmt.Println(tree2str(s))
     }
   #+END_SRC

   #+RESULTS:
   : 2(1)(3)
   : 2()(3)
** convert sorted list to bst
   #+NAME: sorted-list-to-bst
   #+BEGIN_SRC go
     type ListNode struct {
       Val  int
       Next *ListNode
     }

     type TreeNode struct {
       Val   int
       Left  *TreeNode
       Right *TreeNode
     }

     func sortedListToBST(head *ListNode) *TreeNode {
       if head == nil {
         return nil
       }
       length := getListLength(head)
       return sortedListToBSTHelper(head, length)
     }

     func getListLength(head *ListNode) int {
       if head == nil {
         return 0
       }

       return 1 + getListLength(head.Next)
     }

     func getListNth(head *ListNode, nth int) *ListNode {
       if head == nil {
         return nil
       }
       if nth < 1 {
         return head
       }

       return getListNth(head.Next, nth-1)
     }

     func sortedListToBSTHelper(head *ListNode, length int) *TreeNode {
       if length < 1 {
         return nil
       }

       if length == 1 {
         return &TreeNode{
           Val: head.Val,
         }
       }

       if length == 1 {
         return &TreeNode{
           Val: head.Val,
           Right: &TreeNode{
             Val: head.Next.Val,
           },
         }
       }

       mid := length / 2
       mid_node := getListNth(head, mid)
       return &TreeNode{
         Val:   mid_node.Val,
         Left:  sortedListToBSTHelper(head, mid),
         Right: sortedListToBSTHelper(mid_node.Next, length-1-mid),
       }
     }
   #+END_SRC

   #+BEGIN_SRC go :imports "fmt" :noweb strip-export
     <<bt-construct-string>>

     <<sorted-list-to-bst>>

     func main() {
       sortedLst := &ListNode{
         Val: 1,
         Next: &ListNode{
           Val:2,
           Next: &ListNode{
             Val:3,
           },
         },
       }
       fmt.Println(tree2str(sortedListToBST(sortedLst)))
     }
   #+END_SRC

   #+RESULTS:
   : 2(1)
